LLM Router
================================

Overview
--------
This benchmark evaluates a language model’s ability to implement an LLM routing policy. Given a user query, the router must choose one model from a small candidate set with different cost–quality tradeoffs. The goal is to maximize accuracy while minimizing inference cost. The task is fully offline: model correctness and costs are precomputed. The router must generalize from query text alone.

Problem Setting
--------
You operate a router that sits in front of a pool of large language models (LLMs). For each incoming query q, the router must select exactly one model from a fixed candidate set: ["cheap", "mid", "expensive"].

These are abstract routing tiers. Each tier corresponds to a concrete LLM with a known cost and accuracy profile, but this mapping is not visible to the router. Intuitively:
- cheap: fast and inexpensive, but less reliable
- mid: moderate cost and accuracy
- expensive: highest accuracy, highest cost
No single model is optimal for all queries.

Target
--------
The goal is to achieve high accuracy while minimizing average inference cost.

API Specification
--------
Implement a `Solution` class:

```python
class Solution:
    def solve(self, query: str, eval_name: str, candidate_models: list[str]
    ) -> str:
        """
        Select exactly one routing option for the given query.

        Args:
            query: The user query.
            eval_name: The dataset or task name (e.g., "mbpp").
            candidate_models: A list of available routing options 
                              (e.g., ["cheap", "mid", "expensive"]).

        Returns:
            A single string from candidate_models indicating
            the chosen model.
        """
```

**Constraints**:
- The return value must be an element of candidate_models.
- The method is called once per query.
- The solution must be stateless across queries.
- External API calls and internet access are not allowed.

Returning an invalid value results in a score of 0 for that query.

Dataset
--------
For each query and each concrete model, the dataset contains:
- a binary correctness label
- an inference cost
These labels are used only by the evaluator.

During evaluation, the router receives only:
- query
- eval_name
- candidate_models

Scoring (0-100)
--------
The router is evaluated on a fixed set of queries.

For each query:
- The evaluator calls Solution.solve(...).
- The chosen model’s correctness and cost are looked up.
- Accuracy and cost are accumulated.

Let:
- accuracy = fraction of queries answered correctly
- avg_cost = average inference cost per query

The raw score is computed as: raw_score = accuracy − λ × avg_cost, where λ = 20.0.

The final benchmark score is normalized to the range [0, 100], where the oracle router always gets 100. 

Example data
--------
sample_id,prompt,eval_name,WizardLM/WizardLM-13B-V1.2,claude-instant-v1,claude-v1,claude-v2,gpt-3.5-turbo-1106,gpt-4-1106-preview,meta/code-llama-instruct-34b-chat,meta/llama-2-70b-chat,mistralai/mistral-7b-chat,mistralai/mixtral-8x7b-chat,zero-one-ai/Yi-34B-Chat,gpt-3.5-turbo-1106|model_response,claude-instant-v1|model_response,claude-v1|model_response,claude-v2|model_response,gpt-4-1106-preview|model_response,meta/llama-2-70b-chat|model_response,mistralai/mixtral-8x7b-chat|model_response,zero-one-ai/Yi-34B-Chat|model_response,WizardLM/WizardLM-13B-V1.2|model_response,meta/code-llama-instruct-34b-chat|model_response,mistralai/mistral-7b-chat|model_response,gpt-3.5-turbo-1106|total_cost,claude-instant-v1|total_cost,claude-v1|total_cost,claude-v2|total_cost,gpt-4-1106-preview|total_cost,meta/llama-2-70b-chat|total_cost,mistralai/mixtral-8x7b-chat|total_cost,zero-one-ai/Yi-34B-Chat|total_cost,WizardLM/WizardLM-13B-V1.2|total_cost,meta/code-llama-instruct-34b-chat|total_cost,mistralai/mistral-7b-chat|total_cost,oracle_model_to_route_to
mbpp.dev.0,['Write a function to find the shared elements from the given two lists.'],mbpp,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,"[""Here's a Python function to find the shared elements from two given lists:\n\n```python\ndef find_shared_elements(list1, list2):\n    shared_elements = []\n    for element in list1:\n        if element in list2 and element not in shared_elements:\n            shared_elements.append(element)\n    return shared_elements\n\n# Example usage\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [3, 4, 5, 6, 7]\nprint(find_shared_elements(list1, list2))  # Output: [3, 4, 5]\n```\n\nThis function iterates through the elements of the first list and checks if each element is present in the second list. If it is, and it hasn't already been added to the `shared_elements` list, it is added. Finally, the function returns the list of shared elements.""]","['Here is a function to find the shared elements from two lists:\n```python\ndef shared_elements(list1, list2):\n    shared = []\n    for e in list1:\n        if e in list2:\n            shared.append(e)\n    return shared\n```\n\nIt iterates through each element in the first list. \nIf that element is also found in the second list, \nit is appended to the shared list which is returned at the end.\n\nUsage:\n```python\nlist1 = [1, 2, 3, 4]\nlist2 = [2, 4, 5]\n\nshared = shared_elements(list1, list2)\n\nprint(shared)\n# [2, 4]\n```\n\nTime complexity: O(n*m) where n and m are the lengths of the two lists.\nSpace complexity: O(1) since we are only using the shared list of constant size.\n\nHope this helps! Let me know if you have any other questions.']","['Here is a function to find the shared elements from two lists in Python:\n\n```python\ndef shared_elements(list1, list2):\n    shared = []\n    for element in list1:\n        if element in list2:\n            shared.append(element)\n    return shared\n```\n\nThis iterates over the first list, and checks if each element exists in the second list. If so, it adds it to the shared list. Finally it returns the shared list.\n\nFor example:\n```python\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [2, 3, 4, 6, 7]\n\nshared = shared_elements(list1, list2)\nprint(shared)\n# [2, 3, 4]\n```']","['Here is a Python function to find the shared elements from two given lists:\n\n```python\ndef find_shared_elements(list1, list2):\n    shared = []\n    for element in list1:\n        if element in list2:\n            shared.append(element)\n    return shared\n```\n\nTo explain, the function takes two list parameters, `list1` and `list2`. It initializes an empty list `shared` to store the shared elements. \n\nIt then iterates over `list1` and checks if each element is present in `list2` using the `in` operator. If the element is present, it is appended to the `shared` list.\n\nFinally, the `shared` list containing the common elements is returned.\n\nFor example:\n\n```python\nlist1 = [1, 2, 3, 4] \nlist2 = [3, 4, 5, 6]\n\nprint(find_shared_elements(list1, list2))\n# [3, 4]\n```\n\nSo this prints out a list with the shared elements 3 and 4.']","['Certainly! Below is a Python function that takes two lists as input and returns a list of shared elements (i.e., elements that are common to both input lists). This function uses set intersection to find the common elements efficiently.\n\n```python\ndef find_shared_elements(list1, list2):\n    # Convert both lists to sets to remove duplicates and perform intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of both sets\n    shared_elements = set1.intersection(set2)\n    \n    # Convert the set back to a list if you need a list as output\n    return list(shared_elements)\n\n# Example usage:\nlist_a = [1, 2, 3, 4, 5]\nlist_b = [4, 5, 6, 7, 8]\n\nshared = find_shared_elements(list_a, list_b)\nprint(""Shared elements:"", shared)\n```\n\nThis function will output:\n\n```\nShared elements: [4, 5]\n```\n\nKeep in mind that the order of elements in the result list is not guaranteed since sets do not maintain order. If you need the shared elements to be in a specific order (e.g., the order of the first list), you would need to sort the result or use a different approach to maintain the order.']","[' Sure! Here\'s a function that finds the shared elements between two lists:\n```\ndef find_shared_elements(list1, list2):\n    """"""\n    Returns a list of elements that are present in both list1 and list2.\n    """"""\n    list1_set = set(list1)\n    list2_set = set(list2)\n    shared_elements = list1_set.intersection(list2_set)\n    return shared_elements\n```\nHere\'s an explanation of how the function works:\n\n1. We first convert both lists to sets using the `set()` function. This allows us to efficiently find the shared elements between the two lists.\n2. We then use the `intersection()` method of the set class to find the shared elements between the two sets. This method returns a new set containing all the elements that are present in both sets.\n3. Finally, we convert the set of shared elements back to a list using the list() function and return it.\n\nHere\'s an example usage of the function:\n```\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\n\nshared_elements = find_shared_elements(list1, list2)\nprint(shared_elements)  # [4, 5]\n```\nI hope this helps! Let me know if you have any questions.']","[""Sure, here is a simple function in Python that accomplishes this:\n\n```python\ndef shared_elements(list1, list2):\n    return [element for element in list1 if element in list2]\n```\n\nThis function uses list comprehension to create a new list that contains all the elements that are present in both input lists. It iterates over each element in the first list and checks if it also exists in the second list. If it does, then that element is added to the new list.\n\nHere's how you can use this function:\n\n```python\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\n\nprint(shared_elements(list1, list2))  # Output: [4, 5]\n```\n\nIn this example, the function returns a new list containing the shared elements `4` and `5`.""]","[""\n```python\ndef find_shared_elements(list1, list2):\n    # Your code here\n    return shared_elements\n```\n\nTo find the shared elements from two lists, you can use a set intersection. First, convert both lists to sets to perform the operation more efficiently, and then find the intersection of those sets. Finally, convert the intersection back to a list. Here's the code to implement this:\n\n```python\ndef find_shared_elements(list1, list2):\n    # Convert both lists to sets\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of the two sets\n    shared_elements = list(set1.intersection(set2))\n    \n    return shared_elements\n```\n\nThis function `find_shared_elements` takes two lists as arguments and returns a list of elements that are present in both lists.""]","[""Here's a Python function that finds the shared elements from two lists:\r\n\r\n```python\r\ndef find_shared_elements(list1, list2):\r\n    shared_elements = []\r\n    for element in list1:\r\n        if element in list2 and element not in shared_elements:\r\n            shared_elements.append(element)\r\n    return shared_elements\r\n```\r\n\r\nThis function takes two lists as input and returns a list of shared elements. It iterates through the first list and checks if each element is present in the second list and not already in the `shared_elements` list. If both conditions are true, the element is added to the `shared_elements` list.\r\n\r\nHere's an example usage:\r\n\r\n```python\r\nlist1 = [1, 2, 3, 4, 5]\r\nlist2 = [3, 4, 5, 6, 7]\r\nshared_elements = find_shared_elements(list1, list2)\r\nprint(shared_elements)  # Output: [3, 4, 5]\r\n```\r\n\r\nIn this example, the shared elements between `list1` and `list2` are `[3, 4, 5]`.""]","[' \n[PYTHON]\ndef find_shared_elements(list1, list2):\n    return list(set(list1) & set(list2))\n[/PYTHON]\n[TESTS]\n# Test case 1:\nassert find_shared_elements([1, 2, 3, 4], [4, 5, 6, 7]) == [4]\n# Test case 2:\nassert find_shared_elements([1, 2, 3, 4], [1, 2, 3, 4]) == [1, 2, 3, 4]\n# Test case 3:\nassert find_shared_elements([1, 2, 3, 4], [1, 2, 3, 4, 5]) == [1, 2, 3, 4]\n# Test case 4:\nassert find_shared_elements([1, 2, 3, 4], [5, 6, 7, 8]) == []\n[/TESTS]\n']","['Here is a function written in Python that can find the shared elements from two given lists:\n\n```python\ndef shared_elements(list1, list2):\n    # Convert both lists to sets to remove any duplicates and make searching faster\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Find intersection of both sets\n    intersection = set1 & set2\n\n    # Convert the intersection back to list and return\n    return list(intersection)\n```\n\nThis function works by first converting both input lists into sets, which automatically removes any duplicate elements from the lists. Then it finds the intersection of these two sets using the `&` operator, which returns a new set containing only the elements that are present in both sets. Finally, the function converts this intersection back into a list and returns it.\n\nHere is an example of how you can use this function:\n\n```python\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\n\nprint(shared_elements(list1, list2)) # Output: [4, 5]\n```']",0.000386,0.0004864,0.003928,0.005416,0.0083,0.00026189999999999997,0.000123,0.000152,7.35e-05,0.000172272,5.020000000000001e-05,mistralai/mistral-7b-chat
mmlu-abstract-algebra.val.0,"['Please answer with the letter of the correct answer.\n\nFind the degree for the given field extension Q(sqrt(2), sqrt(3), sqrt(18)) over Q.\nA) 4\nB) 0\nC) 2\nD) 6\nPrint only a single choice  from ""A"" or ""B"" or ""C"" or ""D"" without explanation. Answer:']",mmlu-abstract-algebra,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,['D'],['D'],['C'],['C'],['A'],['\nAnswer'],['D)'],['\nC'],['\nB'],['\nI'],['\nA'],8.3e-05,6.720000000000001e-05,0.0006720000000000001,0.0006720000000000001,0.0008399999999999999,7.470000000000001e-05,4.9800000000000004e-05,6.64e-05,2.4900000000000002e-05,6.4408e-05,1.66e-05,mistralai/mistral-7b-chat
